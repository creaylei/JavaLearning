# 大话设计模式

> 轻文社公众号 2019.07.07
>
> [设计模式聚合](https://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247488811&idx=4&sn=ec20f59a5b67a59d98d221bd20d78448&chksm=ebd62a07dca1a31188dafea0e6984b4883fa972a32ff31da2df6f52fcc73b56c6c9454751d73&scene=21#wechat_redirect)

## 1. 什么是设计模式

> Design pattern is a general reusable(可重复使用的) soulution to a commonly occuring problem within context in software design.

**面向对象？**

> 面向对象其实是对现实世界的理解和抽象的方法，也就是在计算机世界里去模拟现实世界的一种编程方法，具体是利用封装、继承、多态的方法去建立模型。

- 封装：实现都放在里面，只留访问接口，使用者无需关注内部具体实现
- 继承：很多功能，资源都是重复的定义，这样会造成极大的冗余和浪费。所以有了继承机制，继承一些重复性的功能和属性。
- 多态：单单继承是不够的，否则直接用父类了。在继承父类的时候，又有自己的特色和属性。比如肉、蛋、奶等可以继承食物，又有自己的特征。塑料就不行

举例：计算机的发展

初始的计算机，都是把所有的东西耦合到一起，随着技术的改进，各个部件逐渐分开，形成了模块化，但是每一种设备都有自己的接口，然后最后统一为了USB接口，双工，5V，供电…… 于是乎，电脑就设计为：

> Computer：“我上面装有一个USB接口，我只认识这个接口传递过来的数据，谁要跟我沟通你就去找它吧。”
>
> USB：“要接驳我的设备是什么我不关心，但我规定设备必须有readData()这个方法，但是怎么实现我不管，总之你得通过这个方法把数据给我。”
>
> Keyboard：“我有readData()这个方法，我已经实现好了，用户一敲键盘我就读过来传给你。 O(∩_∩)O。”

```java
public class computer {
	USB usb;
	setUsb(USB usb);
}

Interface USB {
	readData(String data)
}

class Mouse implements USB{}
class Keyboard implements USB{}
```

该分的分，该合的合，合合分分，分分合合，此乃阴阳之道。

**实战**：Pattern of Gun  枪的演进

- 1.0.0 士兵把子弹放入枪管，然后用棍子戳实了，然后士兵扣动扳机撞击火药爆炸，子弹发射。
- 1.0.1 既然弹药装填麻烦，不如把火药和弹丸组合起来，封装在弹壳中，这样直接装入枪膛一触即发
- 1.1.0 子弹简化了装火药的流程，但是一个一个的装，还是慢，于是出现了弹夹，这相当于压栈(push)，最早压入的子弹最后弹出(pop), 弹夹是对子弹的一个继承
- 2.0.0 加加林，背个弹夹箱实现弹夹接口的标准方法，不停突突突。

```
class Gun {
	IClip clip;
	loadClip(IClip clip);
	shoot();
}

interface IClip {
	push(Bullet bullet);
	pop(): bullet
}
弹夹都实现这个接口
```

## 2. 原型(ProtoType)

### 1. 理解和实战

> 工业生产中的原型，通常是指在量产之前研发出的概念实现，如果可行性满足即可按照原型进行量产。

先区分一个概念

- 印章盖章：印章盖章的那一刹那，其实就是类似于实例化的过程，new Stamp(); 每个盖出的印都可以不一样，例如我们更换了日期，那么每天都有不同日期的实例了，那有人意识到了，同一天的那些实例们，其实是完全一模一样的实例拷贝，那这就比较麻烦，每个文档都要用章子（类）去盖（实例化）一下。
- 标准协议书：行政人员要新建一个word文档了，这个过程其实是在实例化，我们暂且叫它“零号”文件，那当写好了文档后，把这个文件复制给其他公司员工去填写，那么这个零号文件我们就称之为“原型”。

想必我们已经搞明白了，原型模式，**实际上是从原型实例复制克隆出新实例**，而**绝不是从类去实例化**，这个过程的区别一定要搞清楚！OK，那开始我们的实战部分。

**实战**：打飞机的游戏，游戏设定为纵向移动，单打

- 既然是单打，那么我们的主角飞机当然只有一架，于是写一个单例模式，省略主角代码。
- 那么敌机呢？当然是很多架，为了删繁就简，先写个敌机类

```java
 1 public class EnemyPlane {
 2    private int x;//敌机横坐标
 3    private int y = 0;//敌机纵坐标
 4
 5    public EnemyPlane(int x) {//构造器
 6        this.x = x;
 7    }
 8
 9    public int getX() {
10        return x;
11    }
12
13    public int getY() {
14        return y;
15    }
16
17    public void fly(){//让敌机飞
18        y++;//每调用一次，敌机飞行时纵坐标＋1
19    }
20}
```

代码第5行，初始化只接收x坐标，因为敌机一开始是从顶部出来所以纵坐标y必然是0。此类只提供getter而没有setter，也就是说只能在初始化时确定敌机的横坐标x，后续是不需要更改坐标了，只要连续调用第17行的fly方法即可让飞机跟雨点一样往下砸。

- 开始绘制敌机动画了，先实例化出50架吧。

```java
 1 public class Client {
 2    public static void main(String[] args) {
 3        List<EnemyPlane> enemyPlanes = new ArrayList<EnemyPlane>();
 4
 5        for (int i = 0; i < 50; i++) {
 6            //此处随机位置产生敌机
 7            EnemyPlane ep = new EnemyPlane(new Random().nextInt(200));
 8            enemyPlanes.add(ep);
 9        }
10
11    }
12}
```

注意代码第7行，循环中new了50次，会不会出现性能问题呢？当然会，这个实力话的过程是得不偿失的，构造方法调用了50次，cpu被极大的浪费了，内存被极大浪费了，尤其对于游戏来说性能瓶颈绝对是大忌，这会造成用户体验问题，谁也不希望玩游戏会卡帧吧。

那到底什么时候去new？游戏场景初始化就new敌机（如以上代码）？这关会出现500个敌机那我们一次都new出来吧？浪费内存！那我们实时的去new，每到一个地方才new出来一个！浪费CPU！如果敌机线程过多造成CPU资源耗尽，每出一个敌机游戏会卡一下，试想一下这种极端情况下，游戏对象实例很多的话就是在作死。

**解决方案：解决方案到底是什么呢？好，是原型模式Prototype**

> 上代码，我们将敌机改造一下，让他支持原型拷贝。

```java
 1 public class EnemyPlane implements Cloneable{//此处实现克隆接口
 2    private int x;//敌机横坐标
 3    private int y = 0;//敌机纵坐标
 4
 5    public EnemyPlane(int x) {//构造器
 6        this.x = x;
 7    }
 8
 9    public int getX() {
10        return x;
11    }
12
13    public int getY() {
14        return y;
15    }
16
17    public void fly(){//让敌机飞
18        y++;//每调用一次，敌机飞行时纵坐标＋1
19    }
20
21    //此处开放setX，为了让克隆后的实例重新修改x坐标
22    public void setX(int x) {
23        this.x = x;
24    }
25
26    //为了保证飞机飞行的连贯性
27    //这里我们关闭setY方法，不支持随意更改Y纵坐标
28//    public void setY(int y) {
29//        this.y = y;
30//    }
31
32    //重写克隆方法
33    @Override
34    public EnemyPlane clone() throws CloneNotSupportedException {
35        return (EnemyPlane)super.clone();
36    }
37}
```

注意看从第21行开始的修改，setX()方法为了保证克隆飞机的个性化，因为它们出现的位置是不同的。第34行的克隆方法重写我们调用了父类Object的克隆方法，这里JVM会进行内存操作直接<u>**拷贝原始数据流**</u>，简单粗暴，不会有其他更多的复杂操作（类加载，实例化，初始化等等），速度远远快于实例化操作。OK，我们看怎么克隆这些敌机，做一个造飞机的工厂吧。

```java
 1 public class EnemyPlaneFactory {
 2    //此处用痴汉模式造一个敌机原型
 3    private static EnemyPlane protoType = new EnemyPlane(200);
 4
 5    //获取敌机克隆实例
 6    public static EnemyPlane getInstance(int x){
 7        EnemyPlane clone = protoType.clone();//复制原型机
 8        clone.setX(x);//重新设置克隆机的x坐标
 9        return clone;
10    }
11}
```

此处我们省去抓异常，随后的事情就非常简单了，我们只需要很简单地调用EnemyPlaneFactory.getInstance(int x)并声明x坐标位置，一架敌机很快地就做好了，并且我们保证是在敌机出现的时候再去克隆，确保不要一开局就全部克隆出来，如此一来，既保证了实时性节省了内存空间，又保证了敌机实例化的速度，游戏绝不会卡帧！至于此处代码中的懒汉原型还可以怎样优化那就要根据具体场景了，交给大家自由发挥吧，这里只说明主要问题。

### 2. 浅拷贝和深拷贝

最后，还要强调一点就是**浅拷贝和深拷贝**的问题。假如我们的敌机类里有一颗子弹bullet可以射击我们的主角，如下。

```java
1 public class EnemyPlane implements Cloneable{
2    private Bullet bullet = new Bullet();
3    private int x;//敌机横坐标
4    private int y = 0;//敌机纵坐标
5
6    //之后代码省略……
7}
```

> 我们都知道Java中的变量分为原始类型和引用类型，所谓浅拷贝只是拷贝原始类型的指，比如坐标x, y的指会被拷贝到克隆对象中，对于对象bullet也会被拷贝，但是请注意拷贝的只是地址而已，那么多个地址其实真正指向的对象还是同一个bullet。

由于我们调用父类Object的clone方法进行的是浅拷贝，所以此处的bullet并没有被克隆成功，比如我们每架敌机必须携带的子弹是不同的实例，那么我们就必须进行深拷贝，于是我们的代码就得做这样的改动。

```java
 1public class EnemyPlane implements Cloneable{
 2    private Bullet bullet = new Bullet();
 3
 4    public void setBullet(Bullet bullet) {
 5        this.bullet = bullet;
 6    }
 7
 8    @Override
 9    protected EnemyPlane clone() throws CloneNotSupportedException {
10        EnemyPlane clonePlane = (EnemyPlane) super.clone();//先克隆出敌机，其中子弹还未进行克隆。
11        clonePlane.setBullet(this.bullet.clone());//对子弹进行深拷贝
12        return clonePlane;
13    }
14
15    //之后代码省略……
16}
```

相信大家看注释就能懂了，这里就不做过多解释，当然对于Bullet类也同样实现了克隆接口，代码不用再写了吧？相信大家都学会了举一反三。至此，我们的每个敌机携带的弹药也同样被克隆完毕了，再也不必担心游戏的流畅性了。

## 3. 单例

> 顾名思义，整个系统中只能有一个实例，不能再多

**引入**：世界各个国家有众多的神，各信各的，现在我们要定义意为独一无二的神。

先写一个God类，类中空空如也。

`public class God {}`

- 首先，我们得保证任何人都不能去创建神的实例，否则如：new God(), 世界就陷入战争的灾难。那就不写构造方法，不让构造不就行了？  不行，类有默认无参构造方法！ 那就把构造方法改成`private`的，也就是神可以自己创造自己，但别人不能。

```java
public class God{
	private God(){} //构造方法私有化
}
```

God类里面封装一个God自己，对，一切都是神创造的，包括我们人类。有人开始质疑，那神是谁？神自己是谁造的？这是个哲学问题。神说“I am who I am.” 我是我所是，我就是我，自有永有，超越时空。很逆天吧？ 好吧，谁也不能造上帝，神自己造自己。

```java
public class God {
    private static final God god = new God();//自有永有的神单例
    private God(){}//构造方法私有化
}
```

以上private关键字保证了上帝的私有性，不可见性，不可访问性，我想没有活人见过上帝吧？static关键字保证上帝的静态性，他与类同在，不依赖于类的实例化就自有永有，他将在内存中永生，GC垃圾回收器也回收不了他。final关键字则保证这位神是和常量，衡量，他是终极上帝，不能再改。

正如同静态方法main()，不需要实例化类就能运行的入口，同样我们**需要一个静态方法getInstance()来请神**，方法体内我们就返回这个在唯一的真神，当然方法它**必须是public公开的**，不然谁都访问不了。

```java
public class God {
    private static final God god = new God();//自有永有的神单例
    private God(){}//构造方法私有化
    public static God getInstance(){//请神方法公开化
        return god;
    }
}
```

以上的神类雏形已经写好了，当然你还可以加其他的功能方法，比如说创世纪神造了光，造了世界、动物、人、亚当夏娃等等功能，我们这里就不在赘述了。那对于外部来说只要调用God.getInstance();就可以拿到神了，**而且不管谁拿，拿几次，都是同一个神**，这样就保证了整个系统中神的唯一性，不可伪造性，至于其他先知那也只是神的代理人，只能帮请神而已。

- 上面是痴汉模式，一上来就new一个神

好了，其实我们已经学会了单例模式的“痴汉模式（Eager load）”，代码第一行一开始就造出了神（new God那一句），已经准备好了随时给你请神，这样就有了一个问题，如果没人请神那不是白造了？提前备货如果价格跌了不是很惨？反应在系统中的问题就是占用了内存空间。于是又有了“懒汉模式（Lazy load）”

```java
public class God {
    private static God god;//这里不进行实例化
    private God(){}
    public static God getInstance() {
        if (god == null) {//如果无神才造神
            god = new God();
        }
        return god;
    }
}
```

这我们看到一开始就没有造神，只有某人第一次求神时才实例化，之后再求的就直接返回了。这样的好处是省了一段时间的内存（无求神期间），坏处是第一次请神的时候速度相较之前的痴汉模式会慢，因为要消耗CPU去造神。

其实这么写是在多线程模式下是有陷阱的，试想多人同时并发请神的话，依然会造成多神，好吧我们再来改良一下，把请神方法加上synchronized，声明为同步方法，某线程调用前必须获取同步锁，调用完后会释放锁给其他线程用，也就是请神的必须排队，大家一个一个按顺序来。

```java
public class God {
    private static God god;//这里不进行实例化
    private God(){}
    public static synchronized God getInstance() {//此处加入同步
        if (god == null) {//如果无神才造神
            god = new God();
        }
        return god;
    }
}
```

然而，这样做是要付出代价的，还没进庙呢不管三七二十一请神的直接给加锁排队，结果队伍从北边的庙排到了南天门，人们都要来一个一个拜佛求神，这造成了巨大时间浪费，没有充分利用CPU资源并发优势（特别是多核情况）。好吧，那还是让人们抢好了，但依然得保证单例神的情况下。

这里我们去掉方法上的同步关键字，换到方法体内部做同步，整个方法开放并发大家都可以同时入庙，当然起早贪黑的虔诚信徒们要抢头香是必须要入堂排队的。一旦头香诞生，那其他抢香的都白早起，白排队了。再之后的事情我们都可以预见了，头注香被抢后堂内排队再无必要来了，大家可以在堂外同时并发拜佛求神，这就极大的利用了CPU资源。简而言之：只有第一批抢头香的在排队，之后大家都不必排队了，代码如下。

```java
public class God {
    private volatile static God god;
    private God(){} 
    public static God getInstance() {//庙是开放的不用排队进入
        if (god == null) {//如果头柱香未产生，这批抢香人进入堂内排队。
            synchronized(God.class){
                if (god == null) {//只有头香造了神，其他抢香的白排队了
                    god = new God();
                }
            }
        }
        //此处头柱香产生后不必再排队
        return god;
    }
}
```

其实在这之上还发展出了各种各样的单例模式变种，我们这里只讲了最基础的两种，其实他们都各有优缺，我们要做到灵活运用，各取所需。对于我个人来讲倾向于痴汉模式，现在内存成本根本不算问题，况且迟早要被实例化占用内存，加锁解锁更是一种浪费，还有同步效率低等问题，如果上帝不是很占空间那就没必要去懒汉延迟加载，越复杂问题越多，风险越大。



大道至简，无为而治。

## 4. 适配器

> 嘴巴说话，耳朵接听，端和端的沟通靠的是接口。
>
> 如果你和毛里求斯人交流，你们之间的接口对接失效了，说什么完全听不懂！怎么跨越语言的鸿沟？找个翻译吧，那我们说这个翻译就是扮演**适配器（Adapter）**的角色。

顾名思义，适配器，适应当前的不同配置，解决兼容性问题。生活中的电源适配器，变压器都是这类的。

如果还不够形象，那就想想生活中家用电器。 电视机是两项插头，墙上的插孔是三孔的。怎么办，转换器，用优雅微妙的方式化解这种不兼容情况

### 实战

先来一个三项插孔接口

```java
public interface TriplePin {
    //参数分别为火线live，零线null，地线earth
    public void electrify(int l, int n, int e);
}	
```

当然有三项空需要的就实现这个接口，然后我们只定义三项插孔标准electrify(通电)方法，三个参数分布是火线、地线、零线，同样定义两项插孔，只是少了地线，命名为DualPin

```java
public interface DualPin {
    public void electrify(int l, int n);//这里没有地线
}
```

这个是两项的标准，电视正是实现了这个接口

```java
public class TV implements DualPin {

    @Override//既然是两项插头，当然实现两项插标准
    public void electrify(int l, int n) {
        System.out.println("火线通电：" + l);
        System.out.println("零线通电：" + n);
    }
}
```

> 墙上是三项孔，电视实现的是两项孔，看不了电视啊

转换插头，依据设计模式，果断写一个Adapter解决他们之间不可调和的矛盾

> 这时候我们写一个适配器实现三项插头，然后内部有个两项转三项的方法

```java
 1public class Adapter implements TriplePin {
 2
 3    private DualPin dualPinDevice; 
 4
 5    //创建适配器地时候，需要把双插设备接入进来
 6    public Adapter(DualPin dualPinDevice) {
 7        this.dualPinDevice = dualPinDevice;
 8    }
 9
10    //适配器实现的是目标接口
11    @Override
12    public void electrify(int l, int n, int e) {
13        //实际上调用了被适配设备的双插通电，地线e被丢弃了。
14        dualPinDevice.electrify(l, n);
15    }
16
17}
```

意了最关键最精华的部分来了，**第3行**代码意味着这个适配器内部是有一个双插接口的，对于任何双插标准的设备都是可以兼容的OK吗？不明白赶紧看看你家里的适配器。**第6行**的代码完成的过程实际就是你把电视插头接入Adapter了，其实适配器并不在意是什么设备，洗衣机冰箱都可以的，只要是双插标准就可以接入（第一节讲过的多态概念）。**第12行**通电方法实现的是三插标准，但方法体内部**第14行**实际上是在给“某个设备”（是什么设备就看你接什么了）的双插供电，地线e那个参数是用不上的，所以就没有接通，很清晰透彻吧？

当然，除了以上的注入插头的方式（对象适配），还有另一种更简单的方式叫做“类适配器”我们来看下：

```java
1public class ClassAdapter extends TV implements TriplePin{
2
3    @Override
4    public void electrify(int l, int n, int e) {
5        super.electrify(l, n);
6    }
7
8}
```

看出来区别没有？这里并没有注入插头（对象组合），而是把电视机给继承了，这样就可以直接调用父类（TV）的双插通电而不是注入进来去调用，缺点大家也看到了，这适配器继承为TV儿子专用了，洗衣机是用不了啦，作死？其实也不是完全不好，要看具体应用场景哈。

至此，我们的Adapter就差不多完成了，以后再也不用破坏插头了，因为这样重写接口或者修改类的代价太大，如果其他类还有依赖的话，那统统要修改，引入了没有必要的重构，总之暴力修改是违反设计模式的基本原则的，**开闭原则**，指的就是对扩展开放，而对修改关闭，也就是说不要去改动原始类，而是扩展现有功能，提供另一种机制让整个系统实现想要的功能。

最后说下那些概念，归类，名字，什么“类适配器”，“对象适配器”啊，其实，理解不了就算了无所谓，真正的意义在于怎么样在实际工作中灵活运用，实现方式是无穷无尽的，道不清说不尽的，没必要太纠结它到底叫什么，归于哪一类，掌控其背后的道才是最根本的，正如李耳君所言：“道可道，非常道。名可名，非常名。”