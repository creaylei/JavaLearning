# 大话设计模式

> 轻文社公众号 2019.07.07
>
> [设计模式聚合](https://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247488811&idx=4&sn=ec20f59a5b67a59d98d221bd20d78448&chksm=ebd62a07dca1a31188dafea0e6984b4883fa972a32ff31da2df6f52fcc73b56c6c9454751d73&scene=21#wechat_redirect)

## 1. 什么是设计模式

> Design pattern is a general reusable(可重复使用的) soulution to a commonly occuring problem within context in software design.

**面向对象？**

> 面向对象其实是对现实世界的理解和抽象的方法，也就是在计算机世界里去模拟现实世界的一种编程方法，具体是利用封装、继承、多态的方法去建立模型。

- 封装：实现都放在里面，只留访问接口，使用者无需关注内部具体实现
- 继承：很多功能，资源都是重复的定义，这样会造成极大的冗余和浪费。所以有了继承机制，继承一些重复性的功能和属性。
- 多态：单单继承是不够的，否则直接用父类了。在继承父类的时候，又有自己的特色和属性。比如肉、蛋、奶等可以继承食物，又有自己的特征。塑料就不行

举例：计算机的发展

初始的计算机，都是把所有的东西耦合到一起，随着技术的改进，各个部件逐渐分开，形成了模块化，但是每一种设备都有自己的接口，然后最后统一为了USB接口，双工，5V，供电…… 于是乎，电脑就设计为：

> Computer：“我上面装有一个USB接口，我只认识这个接口传递过来的数据，谁要跟我沟通你就去找它吧。”
>
> USB：“要接驳我的设备是什么我不关心，但我规定设备必须有readData()这个方法，但是怎么实现我不管，总之你得通过这个方法把数据给我。”
>
> Keyboard：“我有readData()这个方法，我已经实现好了，用户一敲键盘我就读过来传给你。 O(∩_∩)O。”

```java
public class computer {
	USB usb;
	setUsb(USB usb);
}

Interface USB {
	readData(String data)
}

class Mouse implements USB{}
class Keyboard implements USB{}
```

该分的分，该合的合，合合分分，分分合合，此乃阴阳之道。

**实战**：Pattern of Gun  枪的演进

- 1.0.0 士兵把子弹放入枪管，然后用棍子戳实了，然后士兵扣动扳机撞击火药爆炸，子弹发射。
- 1.0.1 既然弹药装填麻烦，不如把火药和弹丸组合起来，封装在弹壳中，这样直接装入枪膛一触即发
- 1.1.0 子弹简化了装火药的流程，但是一个一个的装，还是慢，于是出现了弹夹，这相当于压栈(push)，最早压入的子弹最后弹出(pop), 弹夹是对子弹的一个继承
- 2.0.0 加加林，背个弹夹箱实现弹夹接口的标准方法，不停突突突。

```
class Gun {
	IClip clip;
	loadClip(IClip clip);
	shoot();
}

interface IClip {
	push(Bullet bullet);
	pop(): bullet
}
弹夹都实现这个接口
```

## 2. 原型(ProtoType)

> 工业生产中的原型，通常是指在量产之前研发出的概念实现，如果可行性满足即可按照原型进行量产。

先区分一个概念

- 印章盖章：印章盖章的那一刹那，其实就是类似于实例化的过程，new Stamp(); 每个盖出的印都可以不一样，例如我们更换了日期，那么每天都有不同日期的实例了，那有人意识到了，同一天的那些实例们，其实是完全一模一样的实例拷贝，那这就比较麻烦，每个文档都要用章子（类）去盖（实例化）一下。
- 标准协议书：行政人员要新建一个word文档了，这个过程其实是在实例化，我们暂且叫它“零号”文件，那当写好了文档后，把这个文件复制给其他公司员工去填写，那么这个零号文件我们就称之为“原型”。

想必我们已经搞明白了，原型模式，**实际上是从原型实例复制克隆出新实例**，而**绝不是从类去实例化**，这个过程的区别一定要搞清楚！OK，那开始我们的实战部分。

**实战**：打飞机的游戏，游戏设定为纵向移动，单打

- 既然是单打，那么我们的主角飞机当然只有一架，于是写一个单例模式，省略主角代码。
- 那么敌机呢？当然是很多架，为了删繁就简，先写个敌机类

```java
 1 public class EnemyPlane {
 2    private int x;//敌机横坐标
 3    private int y = 0;//敌机纵坐标
 4
 5    public EnemyPlane(int x) {//构造器
 6        this.x = x;
 7    }
 8
 9    public int getX() {
10        return x;
11    }
12
13    public int getY() {
14        return y;
15    }
16
17    public void fly(){//让敌机飞
18        y++;//每调用一次，敌机飞行时纵坐标＋1
19    }
20}
```

代码第5行，初始化只接收x坐标，因为敌机一开始是从顶部出来所以纵坐标y必然是0。此类只提供getter而没有setter，也就是说只能在初始化时确定敌机的横坐标x，后续是不需要更改坐标了，只要连续调用第17行的fly方法即可让飞机跟雨点一样往下砸。

- 开始绘制敌机动画了，先实例化出50架吧。

```java
 1 public class Client {
 2    public static void main(String[] args) {
 3        List<EnemyPlane> enemyPlanes = new ArrayList<EnemyPlane>();
 4
 5        for (int i = 0; i < 50; i++) {
 6            //此处随机位置产生敌机
 7            EnemyPlane ep = new EnemyPlane(new Random().nextInt(200));
 8            enemyPlanes.add(ep);
 9        }
10
11    }
12}
```

注意代码第7行，循环中new了50次，会不会出现性能问题呢？当然会，这个实力话的过程是得不偿失的，构造方法调用了50次，cpu被极大的浪费了，内存被极大浪费了，尤其对于游戏来说性能瓶颈绝对是大忌，这会造成用户体验问题，谁也不希望玩游戏会卡帧吧。

那到底什么时候去new？游戏场景初始化就new敌机（如以上代码）？这关会出现500个敌机那我们一次都new出来吧？浪费内存！那我们实时的去new，每到一个地方才new出来一个！浪费CPU！如果敌机线程过多造成CPU资源耗尽，每出一个敌机游戏会卡一下，试想一下这种极端情况下，游戏对象实例很多的话就是在作死。

**解决方案：解决方案到底是什么呢？好，是原型模式Prototype**

> 上代码，我们将敌机改造一下，让他支持原型拷贝。

```java
 1 public class EnemyPlane implements Cloneable{//此处实现克隆接口
 2    private int x;//敌机横坐标
 3    private int y = 0;//敌机纵坐标
 4
 5    public EnemyPlane(int x) {//构造器
 6        this.x = x;
 7    }
 8
 9    public int getX() {
10        return x;
11    }
12
13    public int getY() {
14        return y;
15    }
16
17    public void fly(){//让敌机飞
18        y++;//每调用一次，敌机飞行时纵坐标＋1
19    }
20
21    //此处开放setX，为了让克隆后的实例重新修改x坐标
22    public void setX(int x) {
23        this.x = x;
24    }
25
26    //为了保证飞机飞行的连贯性
27    //这里我们关闭setY方法，不支持随意更改Y纵坐标
28//    public void setY(int y) {
29//        this.y = y;
30//    }
31
32    //重写克隆方法
33    @Override
34    public EnemyPlane clone() throws CloneNotSupportedException {
35        return (EnemyPlane)super.clone();
36    }
37}
```

注意看从第21行开始的修改，setX()方法为了保证克隆飞机的个性化，因为它们出现的位置是不同的。第34行的克隆方法重写我们调用了父类Object的克隆方法，这里JVM会进行内存操作直接<u>**拷贝原始数据流**</u>，简单粗暴，不会有其他更多的复杂操作（类加载，实例化，初始化等等），速度远远快于实例化操作。OK，我们看怎么克隆这些敌机，做一个造飞机的工厂吧。

```java
 1 public class EnemyPlaneFactory {
 2    //此处用痴汉模式造一个敌机原型
 3    private static EnemyPlane protoType = new EnemyPlane(200);
 4
 5    //获取敌机克隆实例
 6    public static EnemyPlane getInstance(int x){
 7        EnemyPlane clone = protoType.clone();//复制原型机
 8        clone.setX(x);//重新设置克隆机的x坐标
 9        return clone;
10    }
11}
```

此处我们省去抓异常，随后的事情就非常简单了，我们只需要很简单地调用EnemyPlaneFactory.getInstance(int x)并声明x坐标位置，一架敌机很快地就做好了，并且我们保证是在敌机出现的时候再去克隆，确保不要一开局就全部克隆出来，如此一来，既保证了实时性节省了内存空间，又保证了敌机实例化的速度，游戏绝不会卡帧！至于此处代码中的懒汉原型还可以怎样优化那就要根据具体场景了，交给大家自由发挥吧，这里只说明主要问题。

最后，还要强调一点就是**浅拷贝和深拷贝**的问题。假如我们的敌机类里有一颗子弹bullet可以射击我们的主角，如下。

```java
1 public class EnemyPlane implements Cloneable{
2    private Bullet bullet = new Bullet();
3    private int x;//敌机横坐标
4    private int y = 0;//敌机纵坐标
5
6    //之后代码省略……
7}
```

> 我们都知道Java中的变量分为原始类型和引用类型，所谓浅拷贝只是拷贝原始类型的指，比如坐标x, y的指会被拷贝到克隆对象中，对于对象bullet也会被拷贝，但是请注意拷贝的只是地址而已，那么多个地址其实真正指向的对象还是同一个bullet。

由于我们调用父类Object的clone方法进行的是浅拷贝，所以此处的bullet并没有被克隆成功，比如我们每架敌机必须携带的子弹是不同的实例，那么我们就必须进行深拷贝，于是我们的代码就得做这样的改动。

```java
 1public class EnemyPlane implements Cloneable{
 2    private Bullet bullet = new Bullet();
 3
 4    public void setBullet(Bullet bullet) {
 5        this.bullet = bullet;
 6    }
 7
 8    @Override
 9    protected EnemyPlane clone() throws CloneNotSupportedException {
10        EnemyPlane clonePlane = (EnemyPlane) super.clone();//先克隆出敌机，其中子弹还未进行克隆。
11        clonePlane.setBullet(this.bullet.clone());//对子弹进行深拷贝
12        return clonePlane;
13    }
14
15    //之后代码省略……
16}
```

相信大家看注释就能懂了，这里就不做过多解释，当然对于Bullet类也同样实现了克隆接口，代码不用再写了吧？相信大家都学会了举一反三。至此，我们的每个敌机携带的弹药也同样被克隆完毕了，再也不必担心游戏的流畅性了。