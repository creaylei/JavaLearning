# 4. 动态规划

## 总纲

一般性问题：求最值

核心问题：**穷举**，   经常存在**「重叠子问题」**，如果暴力穷举效率低下，引入**【备忘录】、【DP table】**

穷举所有也不容易，所以需要列出正确的**【状态转移方程】**

> 三要素：重叠子问题、最优子结构、状态转移方程

难点：写状态转移方程

一个框架思路：**明确 base case -> 明确「状态」-> 明确「选择」 -> 定义 dp 数组/函数的含义**。

```python
# 初始化 base case
dp[0][0][...] = base
# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)

```

PS：但凡遇到需要递归的问题，最好都画出递归树，这对你分析算法的复杂度，寻找算法低效的原因都有巨大帮助。

### 案例：斐波那契数列

还是那个熟悉的数列题

### 1. 暴力递归

存在大量重复子问题，画出递归树

### 2. 备忘录

递归树减枝，引入hash表，记录计算过的节点。 这是一种自顶向下的思考

### 3. DP-Table

自底向上，维护一个数组，每计算一个就放进去

```java
public int fib(int N) {
    if (N == 0) return 0;
    int[] dp = new int[N + 1];
    // base case
    dp[0] = 0; dp[1] = 1;
    // 状态转移
    for (int i = 2; i <= N; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }

    return dp[N];
}
```

![image-20210822105414787](https://tva1.sinaimg.cn/large/008i3skNly1gtpdnzjpitj61400iitc002.jpg)

引出【状态转移方程】

![image-20210822105547370](https://tva1.sinaimg.cn/large/008i3skNly1gtpdpl03kgj60py04q3ym02.jpg)

为啥叫「状态转移方程」？其实就是为了听起来高端。你把 `f(n)` 想做一个状态 `n`，这个状态 `n` 是由状态 `n - 1` 和状态 `n - 2` 相加转移而来，这就叫状态转移，仅此而已。

**千万不要看不起暴力解，动态规划问题最困难的就是写出这个暴力解，即状态转移方程**。只要写出暴力解，优化方法无非是用备忘录或者 DP table，再无奥妙可言。