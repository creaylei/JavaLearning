# 深入理解JVM

# 运行时内存结构(2020-0607)

- **程序计数器**: 

  当前线程字节码的行号指示器。  分支、循环、跳转和线程恢复都依赖这个。   执行native方法的时候，这个计数器的值为空(undefined)。 此区域是唯一一个没有规定`OutOfMemory Error`的情况

- **Java虚拟机栈**: 

  执行方法使用到的栈，线程私有。每个方法有自己的方法栈，执行的时候都会创建一个栈帧。一个方法从执行开始到结束，就是一个栈帧在虚拟机栈入栈和出栈的过程。 

  栈帧：主要用来存储局部变量表、操作数栈、动态链接、方法出口等信息

  两种异常：

  1. 如果线程请求的栈深度，大于虚拟机允许的深度，抛出 `StackOverflow`
  2. 如果虚拟机栈可动态扩展，那么当申请不到足够的内存，会抛出 `OutOfMemory`

- **本地方法栈**

  本地方法栈和虚拟机栈发挥的作用非常类似。  区别是本地方法栈为 native方法服务

- **方法区**

  各个线程共享，主要存储被虚拟机栈加载过的  类型信息、常量、静态变量，即时编译器编译后的代码缓存等

  **运行是常量池**

  运行时常量池是方法区的一部分。 **Class文件中有  类的版本、字段、方法、接口等描述信息。 还有一项信息就是常量池表，用于存放编译期生成的各种字面量和符号引用。**  这部分内容将在类加载后存放到方法区的运行时常量池中。

  JAVA虚拟机对Class文件的每一部分都有严格的规定(类似于协议里面的)。 运行时常量池属于方法区，所以受到方法区的限制，当无法申请足够大小的内存时，就会 OOM

- **堆区**

  所有线程共享，java世界里几乎所有的“对象”实例都在这里创建和分配内存。垃圾收集就发生在这里。

线程私有区域: 程序计数器，本地方法栈，虚拟机栈

线程共享区域：方法区，堆区

**这里需要注意的是：**

- **运行时常量区**

- **直接内存**

  直接内存不属于java虚拟机，但是会导致OOM，所以一起说下。  jdk1.4后新加入了NIO, 它使用native函数库直接分配堆外内存。然后通过一个存储在堆里面的 `DrectByteBuffer` 对象作为这块内存的引用操作。 这样显著提高了性能，避免在 Java堆和native堆中来回复制数据

  > Netty使用了NIO和直接内存



# HotSpot解密

## 对象的创建

检查—分配内存

语言层面的创建：通常是由 new 关键字开始的。 而虚拟机层面是怎么样的呢?

虚拟机层面：

1. 虚拟机接收到一条 new 字节码的指令，(1). 会检查这个指令的参数能否在**常量池**中定位到 **类** 的符号引用，(2). 并且检查这个引用代表的类是否被加载、解析和初始化过。   如果没有，就要进行类加载

2. 分配内存：为新生对象分配内存，目标：把一块确定大小的内存，从JAVA堆中划出来。 依据内存是否工整有两种方式

   - 内存工整，指针碰撞：如果内存是完全工整的,所有使用的都在一边，没使用的在另一边，中间有个指针作为中间指示器，这时候只需将指针往一边移动需要的大小就可
   - 内存不工整，空闲列表(Free List)：内存不工整的情况下，那么虚拟机必须维护一个空闲列表，记录那些内存是可用的，分配的时候就找一块满足需求的划分给对象实例。

   ---

   内存是否规整取决于垃圾收集器是否带有空间**压缩整理**能力。 Serial、ParNew带有压缩整理，就使用指针碰撞。  CMS基于清楚算法使用的是空闲列表。

3. 线程安全问题，

   - 同步处理，多个线程修改，虚拟机采用  CAS + 失败重试。
   - 本地线程分配缓冲(Thread Local Allocation Buffer, TLAB), 把内存分配的动作按照线程划分在不同的空间中进行，即每个线程先在JAVA堆中预先分配一块儿小内存

   内存分配完成后，虚拟机将分配到的内存空间(不包括对象头)都初始化为0值

## 对象内存布局

三部分： 对象头，实例数据，对齐填充

Hotspot对象头包括两类信息

- 存储自身运行时数据Mark Word，hash码，GC分代年龄、锁状态标志，持有锁，偏向线程ID等
- 实例数据，是真正有效信息，我们程序代码里面所定义的各种类型的字段内容。
- 对齐填充，该部分不是必然存在的，仅仅因为 Hotspot要求对象起始内存地址必须是8的整数倍，即任何对象大小都必须是8字节的整数倍

## 对象访问定位

创建对象是为了使用对象，jvm通过 栈上的reference来操作堆上的具体对象

- 句柄访问：java堆中划分一块内存作为句柄池，reference中存储对象句柄地址。 包含两部分： 1. 对象实例数据的指针(指向堆内)  2 对象类型数据的指针(指向方法区常量池)

![image-20200610194654885](https://tva1.sinaimg.cn/large/007S8ZIlly1gfnfn9utuej31ba0hm122.jpg)

- 指针访问：如果直接使用指针，就直接在reference中直接放指向对象的地址，如果直接访问对象就一次找到。这里需要考虑如何放置**对象类型数据**

![image-20200610195128691](https://tva1.sinaimg.cn/large/007S8ZIlly1gfnfs08mo1j31au0hagti.jpg)



