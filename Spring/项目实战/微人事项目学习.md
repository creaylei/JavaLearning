# 微人事项目学习

> http://vhr.itboyhub.com/index.html
>
> 这个作者的文章大都值得学习，这个看完看https://github.com/lenve/javaboy-code-samples

[TOC]

项目概览

![UTOOLS1569739126504.png](https://img02.sogoucdn.com/app/a/100520146/a2cf02c19adf816ab23a5b30f1e333ac)

总体分为： 员工资料、人事管理、薪资管理、统计管理、系统管理

## 1.员工资料

![UTOOLS1569739204779.png](https://img04.sogoucdn.com/app/a/100520146/8be2967710c3aba14dc395279acebf68)

### 添加员工

添加员工，点击添加员工页面，会掉用后端接口

```java
@RequestMapping("/maxWorkID")
    public String maxWorkID() {
        return String.format("%08d", empService.getMaxWorkID() + 1);
    }
```

其中`empService.getMaxWorkId()` 是查询当前库里id最大的记录的  wordId字段，sql如下

```java
<select id="getMaxWorkID" resultType="Long">
        SELECT workID from employee where id=(select max(id) from employee)
    </select>
```

返回给前端8位，工号

![UTOOLS1569739450630.png](https://img04.sogoucdn.com/app/a/100520146/7da668b6f9f9d44a625d7f1107813310)

### 批量删除员工

```java
public boolean deleteEmpById(String ids) {
        String[] split = ids.split(",");
        return empMapper.deleteEmpById(split) == split.length;
    }
```

这里要学习这个返回方式，很精髓

### 首页分页查询所有员工

1. 默认值设置

   ![UTOOLS1569740271937.png](https://img01.sogoucdn.com/app/a/100520146/ad555920b743c1436b57985ce0509ee7)

   这种方式可以避免冗长的代码

2. 物理分页

   ```java
   public list method（Integer page，Integer size）{
   	int start = (page-1)*size;
   }
   ```

   这种物理分页，默认第一页是从0开始，用`limit start, size` 就可以

   但是这里还需要手动查询一次count

3. 日期善用between

   ```xml
   <if test="startBeginDate!=null and endBeginDate!=null">
         AND e.beginDate BETWEEN #{startBeginDate} AND #{endBeginDate}
   </if>
   ```

### ResultMap查询树

![UTOOLS1569743667746.png](https://img01.sogoucdn.com/app/a/100520146/24442ea00ed883a0534c09ff99f46f41)

**通过这种方式，能直接查询出树状结构**

这里的`Collection` 标签，是将查询变为`嵌套查询` 

```
ofType标签      是要返回的集合中pojo对象
select         子查询
column         子查询的入参
property       pojo集合的属性

这里还要注意   <resultMap   type>  中的type标签，中间放的是映射的pojo对象
```

**resultMap是Mybatis最强大的元素，它可以将查询到的复杂数据（比如查询到几个表中数据）映射到一个结果集当中。**

https://www.cnblogs.com/kenhome/p/7764398.html

## 1.权限数据库设计

> 权限是设计有两种方式
>
> 1. SpringSecurity
> 2. Shiro

### 1.权限数据库设计

5张表：资源表、角色表、用户表。   关系表：资源角色关系表、用户角色关系表

![UTOOLS1569813548761.png](https://img03.sogoucdn.com/app/a/100520146/a880e814ddf706cd971a1c7904dfa8bc)

- hr表是用户表，role是角色表，其中name字段表示角色英文名称，按springSecurity的规范，将以`Role_`开始

- menu表是一个资源表，其中有一个`url`字段，表示 urlPattern, 即路径匹配规则。假设有一个路径匹配规则为`/admin/**`,那么当用户在客户端发起一个`/admin/user`的请求，将被`/admin/**`拦截到，系统再去查看这个规则对应的角色是哪些，然后再去查看该用户是否具备相应的角色，进而判断该请求是否合法。

![UTOOLS1569813768689.png](https://img04.sogoucdn.com/app/a/100520146/c4871add68f2c202d8b0dac1e957e411)

### 2. 环境配置

引入依赖

```xml
<!--使用SpringSecurity-->
<dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-security</artifactId>
</dependency>

<!--使用连接池-->
<dependency>
        <groupId>com.alibaba</groupId>
        <artifactId>druid</artifactId>
        <version>1.0.29</version>
</dependency>
```

都是常规的依赖

application.properties

```
spring.datasource.type=com.alibaba.druid.pool.DruidDataSource
spring.datasource.url=jdbc:mysql://127.0.0.1:3306/vhr?useUnicode=true&characterEncoding=UTF-8
spring.datasource.username=root
spring.datasource.password=123

server.port=8082
```

### 3.核心:动态处理角色和资源的关系

> 这里使用的是SpringSecurity技术，详细请看http://mossle.com/docs/auth/html/index.html，这部分是重点

#### **创建Hr和HrService**

实现UserDetails接口，spring-security用户类实现

```java
public class Hr implements UserDetails {
    private Long id;
    private String name;
    private String phone;
    private String telephone;
    private String address;
    private boolean enabled;
    private String username;
    private String password;
    private String remark;
    private List<Role> roles;
    private String userface;
	//getter/setter省略
}
```

看下UserDetails接口

```
public interface UserDetails extends Serializable {
    Collection<? extends GrantedAuthority> getAuthorities();    用户拥有的权限
 
    String getPassword();       获取密码

    String getUsername();      获取用户名

    boolean isAccountNonExpired();      账号是否过期

    boolean isAccountNonLocked();     账户是否被锁

    boolean isCredentialsNonExpired();     密码是否过期

    boolean isEnabled();         用户是否可用
}
```

这个接口默认有7个方法需要实现，但是这个项目业务逻辑目前还不涉及账户的锁定、密码过期等，只有账户是否被禁用，即isEnabled方法。另外，UserDetails中还有一个方法叫做getAuthorities，该方法用来获取当前用户所具有的角色，但是小伙伴也看到了，我的Hr中有一个roles属性用来描述当前用户的角色，因此我的getAuthorities方法的实现如下：

```java
public Collection<? extends GrantedAuthority> getAuthorities() {
    List<GrantedAuthority> authorities = new ArrayList<>();
    for (Role role : roles) {
        authorities.add(new SimpleGrantedAuthority(role.getName()));
    }
    return authorities;
}
```

即，直接从，roles中获取当前用户所具有的角色，构造SimpleGrentedAuthority返回即可。

#### HrService实现UserDetailsService接口

```java
@Service
@Transactional
public class HrService implements UserDetailsService {

    @Autowired
    HrMapper hrMapper;

    @Override
    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException {
        Hr hr = hrMapper.loadUserByUsername(s);    //直接在数据库中按名字查
        if (hr == null) {
            throw new UsernameNotFoundException("用户名不对");
        }
        return hr;
    }
}
```

这里最主要是实现了UserDetailsService接口中的loadUserByUsername方法，在执行登录的过程中，这个方法将根据用户名去查找用户，如果用户不存在，则抛出UsernameNotFoundException异常，否则直接将查到的Hr返回。HrMapper用来执行数据库的查询操作，这个不在本系列的介绍范围内，所有涉及到数据库的操作都将只介绍方法的作用。

#### 自定义FilterInvocationSecurityMetadataSource

`FilterInvocationSecurityMetadataSource` 有一个默认的实现类`DefaultFilterInvocationSecurityMetadataSource` ，该类的主要功能就是通过当前的请求地址，获取该地址需要的用户角色，我们照猫画虎，自己也定义一个`CustomMetadataSource` ，如下

```java
@Component
public class CustomMetadataSource implements FilterInvocationSecurityMetadataSource {
    @Autowired
    MenuService menuService;
    //设置匹配模式
    AntPathMatcher antPathMatcher = new AntPathMatcher();
    @Override
    public Collection<ConfigAttribute> getAttributes(Object o) {
    		//获取请求地址
        String requestUrl = ((FilterInvocation) o).getRequestUrl();
        //获取所有资源
        List<Menu> allMenu = menuService.getAllMenu();
        for (Menu menu : allMenu) {
            if (antPathMatcher.match(menu.getUrl(), requestUrl)
                    &&menu.getRoles().size()>0) {
                    
                //获取当前资源对应的所有角色
                List<Role> roles = menu.getRoles();
                int size = roles.size();
                String[] values = new String[size];
                for (int i = 0; i < size; i++) {
                    values[i] = roles.get(i).getName();
                }
                //返回 List<ConfigAttribute>
                return SecurityConfig.createList(values);
            }
        }
        //没有匹配上的资源，都是登录访问
        return SecurityConfig.createList("ROLE_LOGIN");
    }
    @Override
    public Collection<ConfigAttribute> getAllConfigAttributes() {
        return null;
    }
    @Override
    public boolean supports(Class<?> aClass) {
        return FilterInvocation.class.isAssignableFrom(aClass);
    }
}
```

**关于自定义这个类，我说如下几点：**

1.一开始注入了MenuService，MenuService的作用是用来查询数据库中url pattern和role的对应关系，查询结果是一个List集合，集合中是Menu类，Menu类有两个核心属性，一个是url pattern，即匹配规则(比如`/admin/**`)，还有一个是List,即这种规则的路径需要哪些角色才能访问。

2.我们可以从getAttributes(Object o)方法的参数o中提取出当前的请求url，然后将这个请求url和数据库中查询出来的所有url pattern一一对照，看符合哪一个url pattern，然后就获取到该url pattern所对应的角色，当然这个角色可能有多个，所以遍历角色，最后利用SecurityConfig.createList方法来创建一个角色集合。

3.第二步的操作中，涉及到一个优先级问题，比如我的地址是`/employee/basic/hello`,这个地址既能被`/employee/**`匹配，也能被`/employee/basic/**`匹配，这就要求我们从数据库查询的时候对数据进行排序，将`/employee/basic/**`类型的url pattern放在集合的前面去比较。

这里的顺序非常重要，会使用第一个被匹配的，默认的`DefaultFilterInvocationSecurityMetadataSource` 的介绍入下: 

![image-20190930143436367](/Users/zhangleishuidihuzhu.com/Pictures/wiznote/image-20190930143436367.png)



**这里还有个排序问题，如果按照作者所说那该怎么查数据库呢？** 要求我们从数据库查询的时候对数据进行排序，将`/employee/basic/**`类型的url pattern放在集合的前面去比较

看了下源码，如下

```xml
//dao层
public List<Menu> getAllMenu(){
        return menuMapper.getAllMenu();
}

//mapper层
<select id="getAllMenu" resultMap="BaseResultMap">
      SELECT
	m.*, r.`id` AS rid ,
	r.`name` AS rname ,
	r.`nameZh` AS rnamezh
	FROM
	menu m
	LEFT JOIN menu_role mr ON m.`id` = mr.`mid`
	LEFT JOIN role r ON mr.`rid` = r.`id`
	WHERE
	m.`enabled` = TRUE
	ORDER BY
	m.`id` DESC  
</select>
  
其中ResultMap，认真学习
  <resultMap id="BaseResultMap" type="org.sang.bean.Menu">
        <id column="id" property="id" jdbcType="INTEGER"/>
        <result column="url" property="url" jdbcType="VARCHAR"/>
        <result column="path" property="path" jdbcType="VARCHAR"/>
        <result column="component" property="component" javaType="java.lang.Object"/>
        <result column="name" property="name" jdbcType="VARCHAR"/>
        <result column="iconCls" property="iconCls" jdbcType="VARCHAR"/>
        <result column="keepAlive" property="keepAlive" jdbcType="BIT"/>
        <result column="parentId" property="parentId" jdbcType="INTEGER"/>
        <association property="meta" javaType="org.sang.bean.MenuMeta">
            <result column="keepAlive" property="keepAlive"/>
            <result column="requireAuth" property="requireAuth"/>
        </association>
        <collection property="roles" ofType="org.sang.bean.Role">
            <id column="rid" property="id"/>
            <result column="rname" property="name"/>
            <result column="rnamezh" property="nameZh"/>
        </collection>
        <collection property="children" ofType="org.sang.bean.Menu">
            <id column="id2" property="id"/>
            <result column="path2" property="path" jdbcType="VARCHAR"/>
            <result column="component2" property="component" jdbcType="VARCHAR"/>
            <result column="name2" property="name" jdbcType="VARCHAR"/>
            <result column="iconCls2" property="iconCls" jdbcType="VARCHAR"/>
            <association property="meta" javaType="org.sang.bean.MenuMeta">
                <result column="keepAlive2" property="keepAlive"/>
                <result column="requireAuth2" property="requireAuth"/>
            </association>
            <collection property="children" ofType="org.sang.bean.Menu">
                <id column="id3" property="id"/>
                <result column="name3" property="name" jdbcType="VARCHAR"/>
            </collection>
        </collection>
    </resultMap>
```

简单的理解就是，association查询属性是单个po，collection查询的是`list<Po>` ,为了便于理解，再看看`Menu` 类

```java
public class Menu implements Serializable {
    private Long id;
    private String url;
    private String path;
    private Object component;
    private String name;
    private String iconCls;
    private Long parentId;
    private List<Role> roles;
    private List<Menu> children;
    private MenuMeta meta;
}
```



4.如果getAttributes(Object o)方法返回null的话，意味着当前这个请求不需要任何角色就能访问，甚至不需要登录。但是在我的整个业务中，并不存在这样的请求，我这里的要求是，所有未匹配到的路径，都是认证(登录)后可访问，因此我在这里返回一个`ROLE_LOGIN`的角色，这种角色在我的角色数据库中并不存在，因此我将在下一步的角色比对过程中特殊处理这种角色。

5.如果地址是/login_p，这个是登录页，不需要任何角色即可访问，直接返回null。

6.getAttributes(Object o)方法返回的集合最终会来到AccessDecisionManager类中，接下来我们再来看AccessDecisionManager类。

#### 自定义AccessDecisionManager

自定义UrlAccessDecisionManager类实现AccessDecisionManager接口，如下：

```java
@Component
public class UrlAccessDecisionManager implements AccessDecisionManager {
    @Override
    public void decide(Authentication authentication, Object o, Collection<ConfigAttribute> collection) throws AccessDeniedException, AuthenticationException {
        Iterator<ConfigAttribute> iterator = collection.iterator();
        while (iterator.hasNext()) {
            ConfigAttribute ca = iterator.next();
            //当前请求需要的权限
            String needRole = ca.getAttribute();
            if ("ROLE_LOGIN".equals(needRole)) {
                if (authentication instanceof AnonymousAuthenticationToken) {
                    throw new BadCredentialsException("未登录");
                } else
                    return;
            }
            //当前用户所具有的权限
            Collection<? extends GrantedAuthority> authorities = authentication.getAuthorities();
            for (GrantedAuthority authority : authorities) {
                if (authority.getAuthority().equals(needRole)) {
                    return;
                }
            }
        }
        throw new AccessDeniedException("权限不足!");
    }

    @Override
    public boolean supports(ConfigAttribute configAttribute) {
        return true;
    }

    @Override
    public boolean supports(Class<?> aClass) {
        return true;
    }
}
```

关于这个类，我说如下几点：

1.decide方法接收三个参数，其中第一个参数中保存了当前登录用户的角色信息，第三个参数则是UrlFilterInvocationSecurityMetadataSource中的getAttributes方法传来的，表示当前请求需要的角色（可能有多个）。

2.如果当前请求需要的权限为`ROLE_LOGIN`则表示登录即可访问，和角色没有关系，此时我需要判断authentication是不是AnonymousAuthenticationToken的一个实例，如果是，则表示当前用户没有登录，没有登录就抛一个BadCredentialsException异常，登录了就直接返回，则这个请求将被成功执行。

3.遍历collection，同时查看当前用户的角色列表中是否具备需要的权限，如果具备就直接返回，否则就抛异常。

4.这里涉及到一个all和any的问题：假设当前用户具备角色A、角色B，当前请求需要角色B、角色C，那么是要当前用户要包含所有请求角色才算授权成功还是只要包含一个就算授权成功？我这里采用了第二种方案，即只要包含一个即可。小伙伴可根据自己的实际情况调整decide方法中的逻辑。



## 19.Springboot中自定义参数绑定

> 如何再前端传String类型的日期，后端自动用date类型接受，看这里
>
> [https://github.com/lenve/vhr/wiki/19.SpringBoot%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A](https://github.com/lenve/vhr/wiki/19.SpringBoot中自定义参数绑定)



## 遗留问题

2019-09-29  看了一遍，真厉害