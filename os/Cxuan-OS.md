Cxuan-OS

[toc]

# 1. 认识操作系统

## 1.1 计算机硬件简介

GUI: Graphical User Interface, 图形用户界面

Shell：基于文本，命令行

两种运行模式：

1. 内核态：操作系统运行在**内核态**中
2. 用户态：软件的其余部分运行在用户态中

硬件分类：CPU、内存、I/O设备。都和总线串联起来

- CPU: 每种CPU都有一组特定指令集， 如 x86, ARM。  CPU里面包含一些「寄存器」，用来存储关键变量和临时结果。 除了这些还有一些特殊的「寄存器」，包括【程序计数器】【堆栈指针】【PSW( Program Status Word)】

- 多线程和多核芯片： 多线程不多说了，多核芯片：现代许多CPU上都有4、8个完整处理器或内核。  有两种，**多核共享L2缓存**，多核**独立**L2缓存

  GPU：指成千上万个微核组成的处理器。

- 内存：理想情况，应该满足 ： 快、大、便宜。      快和便宜矛盾

  ![image-20210304112606759](https://tva1.sinaimg.cn/large/e6c9d24ely1go7pmfro6sj21py0kcady.jpg)

  高速缓存： L1、L2

  主存： RAM, ROM

- I/O设备

- 总线：（Bus）**是计算机各种功能部件之间传送信息的公共通信干线**，它是由导线组成的传输线束， **按照计算机所传输的信息种类**，**计算机的总线可以划分为数据总线**、**地址总线和控制总线**，分别用来传输数据、数据地址和控制信号。

## 1.2 操作系统概念

进程：一个运行程序。  相关概念：地址空间、进程表、进程间通信

地址空间：一个进程在主存中可使用的地址集合，0——某个最大值	

文件：几乎所有的操作系统都支持文件系统。   `/`代表根路径

> Unix中有个重要概念是  `特殊文件` ， 块特殊文件 和 字符特殊文件
>
> 管道：Pipe， 可以连接两个进程，是一种虚文件

保护：Unix通过给每个文件赋予一个9位二进制保护代码，对文件实施保护。   如：`rwxr-x--x` , 9位分为3段，分别对应三个角色：所有者，与所有者同组的其他成员，其他人。    这就是著名的 `rwx`   可读， 可写， 可执行

Shell：很重要，但不是操作系统的组成部分。 包括： `sh ，csh，ksh,bash ` 等。

>  `|` 管道符，将前面的输出，作为后面的输入

## 1.3 系统调用

### 用于进程管理的系统调用

`fork()` :fork之后， 原有进程以及副本（父与子）就分开了，fork过程中，所有变量都有相同的值。

`waitpid`:父进程可以使用该命令等待子进程执行完毕。

### 用于文件管理的系统调用

最常用的是`read  write` 

### 用于目录管理的系统调用

`mkdir和rmdir`表示创建和删除

插入usb后，会执行 mount 命令，将系统文件树组合

---

Unix程序由执行某些操作或执行其他操作的代码组成；Windows则不同，通常是由事件驱动的。

## 1.4 操作系统结构

单体结构、分层系统、微内核、客户-服务端系统、虚拟机和外核。

### 单体系统

### 分层系统

### 微内核

传统上，所有的层都在内核中，但是内核中的问题很难处理；所以，为了实现高可靠性，细分操作系统模块， 只将——微内核——运行在内核态中。

![image-20210307150402547](https://tva1.sinaimg.cn/large/008eGmZEly1gobcs8o7ulj31b00ngdmm.jpg)

微内核思想的策略是把进程划分为两类：**服务器**：提供服务；**客户端**：使用这些服务。即 客户—服务器模式。

# 2 进程和线程

## 2.1 进程

进程：操作系统最核心的概念。就是一个正在执行的程序实例。 这里有个`伪并行`，单核CPU通过快速的上下文切换，做到用户无感知。

### 进程模型

进程是某一类特定活动的总和，他有程序、输入输出以及状态。

### 进程的创建

- 系统初始化(init)： 启动操作系统时候，会创建若干进程，这些进程运行在后台用来处理一些活动，如e-mail、web网页等，被称为`守护进程(daemons)` 。 UNIX： ps   Win: 任务管理器
- 正在运行的程序执行了创建进程的系统调用`fork`
- 用户请求创建一个新进程： 交互式系统中，一个命令或者双击图标
- 初始化一个批处理工作

### 进程的终止

- 正常退出(自愿)
- 错误退出(自愿)
- 严重错误(非自愿)
- 被其他进程杀死(非自愿)

### 进程的层次

一个进程创建了其他进程后，父进程和子进程会以某种方式进行关联。一层一层，形成一个层级结构。

### 进程的状态

运行、阻塞和就绪。 逻辑上讲运行态和就绪态是很相似的。这两种情况都可运行，但是就绪态没有获得CPU时间片。

操作系统底层就是调度程序，在它之上有许多进程。 所有关于中断处理、启动进程和停止的细节都隐藏在调度之中。事实上，调度程序是一段非常小的程序。

### 进程的实现

操作系统为了执行进程间的切换，维护了一个`进程表(process table)`

`中断向量(interrupt vector)` 。 一个中断处理和调度的过程：![image-20210307171650122](https://tva1.sinaimg.cn/large/008eGmZEly1gobgmajvgnj31040fyn1f.jpg)

## 2.2 线程

有了进程，为什么还要线程，也就是说线程的优缺点：

- 多线程可以共享同一块地址空间和所有可用数据的能力，进程不具备
- 线程更轻量级，更容易创建和销毁。 一般创建一个线程要比创建一个线程快 10-100倍
- 性能：如果多线程都是CPU密集型，那么并不能获得性能上的增强。 但是如果有大量计算和大量I/O处理，拥有多线程能在这些活动中彼此重叠进行，加快速度

### 多线程解决方案、单线程解决方案和状态机解决方案

| 模型       | 特性                           |
| ---------- | ------------------------------ |
| 单线程     | 无并行性，性能差，阻塞系统调用 |
| 多线程     | 有并行性，阻塞系统调用         |
| 有限状态机 | 并行性，非阻塞系统调用、中断   |

线程不像是进程那样具备较强的独立性。同一个进程中，所有线程都会有完全一样的地址空间，这意味他们共享统一的全局变量。

线程的状态：运行中、阻塞、就绪和终止。

**线程之间**的状态转换和**进程之间**的状态转换是一样的。

### 线程系统调用

举几个例子：

| 线程调用       | 描述                             |
| -------------- | -------------------------------- |
| pthread_create | 创建                             |
| pthread_exit   | 结束调用的线程                   |
| pthread_join   | 等待一个特定线程退出，再继续执行 |
| pthread_yield  | 释放CPU来运行另一个线程          |

### 线程实现

#### 在用户态中实现线程 

优势：

1. 切换线程的时候，保存线程的状态和调度程序都是「本地过程」，启动他们比进行内核调用效率更高，因而不需要切换到内黑，也不用切换上下文，也不需对告诉缓存进行刷新，以为敏捷，所以高效
2. **用户空间允许每个进程有自己的调度算法。**例如，某些程序中，具有垃圾线程的程序（如JAVA），就不用担心自己线程会不会在不合适的时候停止。   

劣势：

1. `阻塞调用的实现`：让线程进行系统调用是不可能的，因为这会停止所有的线程。 所以，使用线程的一个目标是能够让线程进行阻塞调用，并避免影响其他线程。
2. `缺页中断`： 内存不会一次把所有程序都放入内存，如果某个函数调用或者跳转到一条不在内存的指令上，就会发生**页面故障**，需要到磁盘读这个缺失的指令，这就称为“缺页故障”。这时候内核不知道线程的存在，会阻塞整个进程。知道I/O完成

#### 内核空间实现

此时，内核中间维护一个，进程表和一个线程表。内核可以感知到所有状态

- 对于阻塞调用：当一个线程阻塞，内核可以选择是运行同一个进程中的其他线程，还是另一个进程中的线程
- 对于缺页故障，内核很容易检查其他线程是否可运行，然后可以运行其他线程。
- 弊端就是：内核中创建和销毁线程开销比较大， 有些策略是使用线程池

#### 用户和内核空间中混合实现

创造了一种 `内核级线程`

---

## 2.3 进程间通信

3个问题

- 一个进程如何传递消息给其他进程？
- 如何确保两个或者多个进程之间不会干扰？
- 顺序问题， A打印数据传给B打印，则B打印数据之前要等A产生数据后打印

这三个问题中后两个问题同样也适用于线程。 

> 自己想想为什么第一个不使用？ 想想JMM，内存模型
>
> 因为共享一个地址空间，具有相同的运行时环境

### 竞态条件：两个线程或进程同事对一共享数据进行修改，影响了程序运行的正确性

### 临界区域:   把对共享内存进行访问的程序片称为「临界区域」或「临界区」

解决方案就是：正确操作，是两个不同进行不可能同时处于临界区，就能避免竞争条件。 还要保证高效性，好的解决方案包含下面四种条件

1. 任何时候两个进程不能同时处于临界区
2. 不应对CPU的速度和数量做任何假设
3. 位于临界区外的进程不得阻塞其他进程
4. 不能是任何进程无限等待进入临界区

### 忙等互斥

#### 屏蔽中断

单处理器系统上，最简单的方法就是在进入临界区后`屏蔽所有中断`, 离开临界区前重启他们。 屏蔽中断后，时钟中断也会屏蔽。CPU只有在时钟中断或其他中断时才会进行进程切换。

屏蔽中断对操作系统本身很有用，但是对用户线程不是一项通用的互斥机制

#### 锁变量

set before check 不是原子性操作，还会引发竞争条件

#### 严格轮询法

连续检查一个变量直到某个值出现，这种方法称为`忙等待` ，由于这种方式浪费CPU，所以通常应该避免。 用于忙等待的锁，称为 **自旋锁**。 这种会出现描述3的场景，所以也不是一个好方法。

#### 硬件支持 TSL、XCHG

总线锁， x86架构底层同步使用XCHG指令

### 睡眠与唤醒：生产者消费者问题，

### 信号量semaphore：信号量的值+1，和-1是原子的

### 互斥量mutex

如果不需要信号量的计数能力，可以使用信号量的简化版本`互斥量` ， 只有加锁和解锁两种状态，0表示解锁，>0表示加锁几次。

Futexes、Pthreads

### 管程

管程是程序、变量和数据结构组成的一个集合。

### 消息传递

### 屏障

用于进程组之间的生产-消费者模式，规定除非所有的进程都就绪准备进入下一个阶段，否则任何进程都不能进入下一个阶段。

---

## 2.4 调度

### 介绍

解决一个CPU应该给谁使用，多个进程/线程进行竞争的时候，到底应该给谁。这就是`调度算法` 。

![image-20210407153537629](https://tva1.sinaimg.cn/large/008eGmZEly1gpb7wlcbmxj31de0mk76o.jpg)

#### 何时调度

1. 创建进程后，父子进程都处于就绪，可以随机调度运行
2. 进程退出时需要作出调度决定，因为此进程将不在，就从就绪中的进程选择其他进程运行
3. 进程阻塞在I/O、信号量或其他原因时，必须选择另一个进程来运行。
4. I/O中断发生时候，可以做调度决策。

#### 调度算法

三种环境：批处理(Batch)、交互式(Interactive)、实时(Real Time),  不同的环境有不同的调度目标。

- 批处理：非抢占式算法或周期性比较长的抢占式算法，这样可以减少线程切换提升性能
- 交互式：避免一个进程霸占CPU而拒绝给其他进程服务，需要抢占式算法
- 实时：抢占有时是不需要的

#### 调度算法的目标

| 所有系统   | 公平：给每个进程公平的CPU份额<br />策略强制执行：保证规定的策略被执行<br />平衡：保持系统的所有部分都忙碌 |
| ---------- | ------------------------------------------------------------ |
| 批处理系统 | 吞吐量：每小时最大作业数量<br />周转时间：从提交到终止间的最小时间<br />CPU利用率：保持CPU时钟忙碌 |
| 交互式系统 | 响应时间：快速响应请求<br />均衡性：满足用户的期望           |
| 实时系统   | 满足截止时间：避免数据丢失<br />可预测性：多媒体系统中避免品质降低 |

### 2.4.2 批处理中的调度

- 先来先服务：队列实现
- 最短作业优先：耗时最短的优先
- 最短剩余时间优先

### 2.4.3 交互式系统中的调度

- 轮询调度：固定的时间片，用完就换进程。 这里注意上下文切换是耗时的，固定的时间片设置最好的切换时间的20-50ms，设置太短上线文切换过多并降低CPU，设置太长会导致一个短请求很长时间得不到响应
- 优先级调度：先对优先级高的用轮询法，直至下一级再轮询
- 最短进程优先：如何预估最短，一种方式是根据过去的行为预测。
- 保证调度：每个进程将获得1/n CPU时间
- 彩票调度：将系统的资源(例如CPU时间片)视为彩票。当做一次调度的时候就随机抽一张彩票，拥有彩票的进程获得该资源。  CPU调度时，系统每秒持有50次抽奖，每个中奖者将获得20毫秒的时间奖励。一些重要的进程可以多给几张彩票，增加中奖概率。   一共100张，某个线程给20张

### 2.4.4 实时系统的调度

硬实时和软实时

# 3. 内存

## 3.1 一种存储器抽象：地址空间

`地址空间`：创建了一种抽象内存供程序使用。是进程可以用来寻址空间的地址集。每个进程都有自己的地址空间，独立于其他进程的地址空间，但是某些进程会希望可以共享地址空间。

### 基址寄存器和变址寄存器

- 基址寄存器：存储数据内存的起始位置
- 变址寄存器：存储应用的长度

### 「交换技术」

- 空闲内存管理

  两种监控内存使用的方式

  1. 位图(bitmap)
  2. 空闲列表 (free lists) : 用链表实现

### 虚拟内存

小应用内存小，尚可交换，但是随着软件越来越大，难道要一次交换成G的内存。显然是不合适的。引入虚拟内存。

思想：每个程序都有自己的地址空间，这些地址空间被划分为多个称为 页面（Page）的块。每一页都是连续的地址范围。  这里有个MMU内存管理单元，类似翻译官，将虚拟内存翻译为物理内存。

- 分页：每页的起始是4096的倍数，结束于4095的位置

![image-20210408173610598](https://tva1.sinaimg.cn/large/008eGmZEly1gpch0bgnuvj31rk0tg43s.jpg)

- 如何映射

  页框号 = 页表(虚拟页号)     y = f (x) 

#### 页面置换算法：

1. `最优算法`：在当前页面中置换最后要访问的页面。不幸的是，没有办法判断哪个页面是最后一个要访问的。一次实际该算法不能使用
2. NRU: not frequency use， 算法根据R位和M位状态将页面分为4类，从编号最小的类别中随机选择一个页面，NRU算法易于实现，但是性能不够好，存在更好的算法
3. FIFO：先入先出，该算法也不够好
4. 第二次机会：是对FIFO的一个优化，会删除页面之前检查这个页面是否仍在使用，如果使用就保留。这个改进大大提高了性能
5. 时钟算法：和第二次机会算法类似。但是会花费更少的时间来执行算法
6. LRU：算法很优秀，但是没有 特殊硬件 TLB 很难实现，如果没有硬件，不能使用
7. NFU：近似LRU，但是性能不够好
8. 老化算法：接近LRU，且可以更好实现

---

# 4. 文件系统

进程和线程的抽象、地址空间和文件都是操作系统的重要概念

文件由操作系统进行管理，有关文件的构造、命名、访问、使用、保护、实现和管理都是操作系统设计的主要内容

## 4.1 文件

文件命名：UNIX区分大小写，Win不区分。  unix对扩展名不强制，win有强制

文件结构：常见三种：1. 字节序列 2. 记录序列 3. 树 。   UNIX 和 Windows都是采用1

文件类型：UNIX 和 Windows 都具有常规的文件和目录。  除此， UNIX还有 字符特殊文件、块特殊文件

- UNIX在shell中嵌入了 `make` 程序，

文件访问： 序列访问、随机访问文件

文件属性：保护、密码、创建者、所有者、只读标志、隐藏标志

文件操作：create、delete、open、close、read、wirte、append、seek(对于随机访问的文件，指定从何处开始获取数据)、rename、 get attributes、 set attributes

## 4.2 目录

一级目录系统：有一个能够包含所有文件的目录，这种目录被称为`根目录`

层次目录系统：也称目录树，现代操作系统都是这样的方式

路径名：

- 绝对路径：从根目录到文件的路径， 如果第一个字符就是分隔符，就是绝对路径。  绝对路径UNIX 以 `/` 开头 ，win中是用`\`开头
- 相对路径：当前路径下可以省略从根目录到目前文件的前缀
- `.` 和`..`： `.` 是指当前目录， `..` 是指父目录

目录操作：create、delete、opendir、closedir、rename、link、unlink

## 4.3 文件系统的实现

文件系统存储在磁盘中的。磁盘可以分区，每个分区都有独立的文件系统。

![image-20210507171547250](https://tva1.sinaimg.cn/large/008i3skNly1gq9ze1cmtxj319k0scq7n.jpg)

引导块：每个分区都有引导块，引导块中的程序加载分区中的操作系统

超级块：包含文件系统所有关键参数， 文件系统大小、文件系统中的数据块数、指示文件系统状态的标志、分配组大小

空闲空间块：位图或指针表

Inode: 索引节点，每个文件都有一个inode，说明了文件的方方面面。 包括：模式、权限，  所有者ID，组ID，文件大小， 命令`ls -lai`

### 文件的实现

最重要的是记录文件使用了哪些块儿。不同的系统采用的方式不同，主要的思想是：“有效利用空间”和“快速访问文件”，分为

- 连续分配， 类似数组，连续的块，优点：快，缺：难处理断续的点
- 链表分配， 类似链表
- 索引分配：给每个文件赋予一个称为`inode`的数据结构，每个文件都与一个inode关联，

### 目录的实现

### 共享文件

